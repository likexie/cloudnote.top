## 1. 命令终端

1. 查看当前用户

   ```shell
   # 初始条件介绍
   # 使用Termius和启动的机器终端，也就说有两个终端
   [root@zhuRoot ~]# who
   root     pts/0        2021-05-29 17:52 (192.168.1.111)
   root     tty6         2021-05-29 17:53
   # 使用who 展示当前在线的用户终端
   # 第一个就是当前的用户
   # 第二个是另外一个机器终端
   pts:虚拟终端，也就是用第三方工具连接的终端
   #pty（pseudo terminal device）由两部分构成，ptmx是master端，pts是slave端， #进程可以通过调用API请求ptmx创建一个pts，然后将会得到连接到ptmx的读写fd和一个新创建的pts， #ptmx在内部会维护该fd和pts的对应关系，随后往这个fd的读写会被ptmx转发到对应的pts
   tty（Teletype ）6:是linux中自带的用户，一般有tty1-tty6个中终端
   # 问题：要这么多终端干嘛？
   # 答案：终端也是一个进程，当有一个终端坏了或者在执行其他的命令，可以切换为其他的终端这样可以可以来回切换，不至于无法操作。
   
   
   ```

2. 使用kill管理其他终端进程

   ![image-20210529181059951](C:/Users/dell/AppData/Roaming/Typora/typora-user-images/image-20210529181059951.png)

   ​	可以看到后面的数据是PID前面有➕号的代表在线。

3. vi分屏
```shell
:sp上下分屏
ctrl+ww 使用切换屏幕
:vsp head.txt 打开一个新文件左右分屏
ctrl+ww 使用切换屏幕
:wq 保存关闭当前的一个
:wqall保存关闭所有的文件


```
4. gcc
```shell
gcc h.c -o app -I include -D DEBUG -O(1/2/3)代码优化
-O1:代码一般优化
-02:二般优化
-03:三般优化
比如
int a=10
int b=a
int c=b
直接优化为int c=10
-Wall 输出警告信息
-g:调试的时候使用
-c 只编译子程序
-E 生成预处理文件
-D 添加定义宏
-o 生成那个文件
-I 头文件目录   
```