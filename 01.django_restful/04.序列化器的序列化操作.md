# DRF 框架（15.序列化器的序列化操作）

 

## 1. 使用方式

1. 安装DRF 

   ```python
   pip install djangorestframework
   ```

   

2. 添加rest_framework应用

   ```python
   INSTALLED_APPS = [
       'django.contrib.admin',
       'django.contrib.auth',
       'django.contrib.contenttypes',
       'django.contrib.sessions',
       'django.contrib.messages',
       'django.contrib.staticfiles',
       'rest_framework',# DRF 应用
       'appindex', # 注册的应用
   ]
   ```

3. 创建序列化器

   ```python
   from rest_framework import serializers
   from .models import BookInfo
   
   
   class BookInfoSerializer(serializers.ModelSerializer):
       """定义序列化器"""
       class Meta:
           model = BookInfo # 指定序列化从那个模型映射字段
           fields = "__all__" # 映射哪些字段
   ```

4. 编写视图逻辑

   ```python
   
   class BookInfoView(ModelViewSet):
       """
       定义视图类
       """
       # 指定查询集
       queryset = BookInfo.objects.all()
       # 指定序列化器 属性必须是serializer_class 不能是其他的名字
       serializer_class = BookInfoSerializer
   
   ```

5. 定义路由

   ```python
   from django.urls import path, include, re_path
   from appindex import views
   from . import views
   from rest_framework.routers import DefaultRouter 
   
   
   urlpatterns = [
       # 列表视图的路由
       # re_path(r'^books/$', views.BookListView.as_view()),
       # 详情视图的路由
       # re_path(r'^books/(?P<pk>\d+)/$', views.BookDetailView.as_view())
   ]
   
   router = DefaultRouter() # 创建路由器
   router.register('books', views.BookInfoView) # 注册路由
   urlpatterns += router.urls # 包生成好的路由进行拼接
   ```

6. 运行测试

   ```python
   GET http://127.0.0.1:8000/books/
   ```

## 2. 序列化和反序列化介绍

1. 提示在开发REST API接口时，视图中做的最主要有三件事:

   - 将请求的数据（如JSON格式）转换为模型类对象（反序列化）
   - 操作数据库
   - 将模型类对象转换为响应的数据（如JSON格式）（序列化）

2. 序列化

   - 概念

     将程序中的一个数据结构类型转换为其他格式（字典，JSON，XML等）

   - 序列化行为

     ```python
     
     class BookListView(View):
         '''
         列表视图
         '''
         def get(self,request):
             '''
             $查询所有图书$
             '''
             # 1. 查询所有图书模型
             books = BookInfo.objects.all()
             # 2. 遍历查询集，取出每一个对象，把模型转为字典。
             book_list = list()
             for book in books:
                 book_dict = {
                     'btitle': book.btitle,
                     'bpub_date': book.bpub_date,
                 }
                 book_list.append(book_dict)
             # 3. 响应
             return JsonResponse(book_list, safe=False)
     ```

   - 序列化时机

     当需要给其那段响应模型数据时，需要将模型数据序列化成前端需要的格式

3. 反序列化

   - 概念

     将其他格式（字典，JSON，XML等）转为程序中的数据，例如将JSON转为DJango中的模型类型

   - 反序列化行为

     ```python
     def post(self,request):
             '''
             新增图书
             '''
             # 1. 获取前端传入的请求题，request.body
             json_str_bytes = request.body
             # 2. 把bytes类型的json字符串转换成，json_str
             json_str = json_str_bytes.decode()
             # 3. 利用json.loads将json字符串转为dict
             book_dict = json.loads(json_str)
             # 4. 创建一个新的数据库模型对象
             book_obj = BookInfo(
                 btitle=book_dict['btitle'],
                 bpub_date=book_dict['bpub_date']
             )
             book_obj.save()
             # 5. 插入数据
             # 6. 保存
             # 7. 返回数据状态码201
             json_dict = {
                 'id': book_obj.id,
                 'btitle': book_obj.btitle,
                 'bpub_date': book_obj.bpub_date,
             }
             return JsonResponse(json_dict, status=201)
     ```

   - 反序列化时机

     当需要将用户发送的数据存储到数据库之前，需要用反序列化

4. 序列化器 

   - 序列化器的作用

     1. 对数据进行转换 序列化（输出，read_only）和反序列化（输入，write_only）
     2. 进行数据的校验 判断用户发送的数据是否合法   is_valid(raise_execption=True)

   - 定义序列化器说明

     1. 模型类与序列化器对比

        ```python
        ==模型类==
        # 图书模型类
        class BookInfo(models.Model):
            '''
            图书模型类
            '''
            btitle = models.CharField(max_length=256, verbose_name='图书名称')
            bpub_date = models.DateField(verbose_name='出版时间')
        
            # 重写魔法方法，返回书名
            def __str__(self):
                return self.btitle
        
        
        ==序列化器==
        class BookInfoTestSerializer(serializers.Serializer):
            """
            获取书籍测试序列化数据
            """
            id = serializers.IntegerField(label="ID",read_only=True)
            btitle = serializers.CharField(max_length=20,required=True)
            bpub_date = serializers.DateField(label="发布时间")
        ```

        字段类型必须一致，且需要对应。如：btitle对btitle，序列化器中可以出现自定义的

        BookInfoTestSerializer(instace, data)

        - 参数 instance ：传值表示序列化 BookInfoTestSerializer(instace=data)

        形参可以是字典、查询集、模型

        - 参数data：传值表示反序列化

        

## 3. 序列化器操作及其关联序列化

1. 添加新的属性，直接在序列化中添加新的属性即可。

   ```python
   增加属性hello
   class BookInfoTestSerializer(serializers.Serializer):
       """
       获取书籍测试序列化数据
       """
       id = serializers.IntegerField(label="ID",read_only=True)
       btitle = serializers.CharField(max_length=20,required=True)
       bpub_date = serializers.DateField(label="发布时间")
       hello = serializers.CharField()
   使用的时候
   book = BookInfo.objects.get(id=1)
   book.hello = "hello"
   s = BookInfotestSerializer(book)
   s.data
   输出结果为：
   {'id': 1, 'btitle': '射雕英雄传1', 'bpub_date': '2021-03-17', 'hello': 'hello'}
   ==注：
   如果没有在序列器中增加属性，直接赋值序列化时不进行添加，序列化只显示序列化器中有的属性
   book.no = 1
   ```
   

   
2. 序列化关联有三种方式
  
      ```python
      当英雄和书关联的时候,在英雄的类中外键可以这么写。
      # 默认是将关联模型的__str__方法返回值序列化出来
      1. hbook = serializers.StringRelatedField()
      # 默认将关联模型的id序列化（其后必须有参数read_only或者queryset）
      2. hbook = serializers.PrimaryKeyRelatedField(label="书籍", read_only=True)
      # queryset=BookInfo.objects.all()表示，如果反序列化时该书对象不在BookInfo中那么报错
      3. hbook = serializers.PrimaryKeyRelatedField(label="书籍", queryset=BookInfo.objects.all())
      # 关联模型对象的序列化器中所有字段序列化出来
      3. hbook = BooInfoSerializer()
      
      ```

3. 一对多和多对一的关联
  
      ```python
      多关联一的时候使用
      hbook = BooInfoSerializer()
      一关联多的时候(用类名_set并且记得指定many=True)
   heroinfo_set = HeroInfoSerializer(many=True)
   ```
   
      

