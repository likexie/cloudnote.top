# ModelSerializer简介
1. 父类serializer
2. 相对于父类，ModelSerializer实现了update和create方法，并且可以对应类型进行映射，不需要写每个字段了。
3. 使用方法
```python
class BookInfoSerializer(serializer.ModelSerializr):
    
    class Meta:
        # 指定序列化器字段从那个模型去映射
        model = BookInfo
        # 1. 映射的字段有哪些
        fields = "__all__"
        # 2. 执行某些字段
        # fields = ['id','name']
        # 3. 除了某些字段不要,除了name 其他都要
        # exclude = ['name']
        # 4 修改某些参数
        extra_kwargs={
            'name':{'label':'名称','required':True},
            # 只对某字段反序列化
            'bcomment':{"write_only":True}
        }
        # 5 只进行序列化
        read_only_fields=['id','name']
        # 没有write_only 只有read_only_fields字段
        
```
# 2. Request与Response
1. Request
RSET Framework 传入视图的request对象，不再是Django默认的对象HttpRequest对象，而是REST Framework 提供的扩展了HttpRequest类的Resquest类的对象
REST 提供了Parser解析器，在接收到请求后会自动根据Content-Type指明的请求数据类型（如JSON,表单等）将请求数据进行parse 解析，解析为类字典对象保存到Request对象中。
**Request对象的数据是根据前端发送数据的格式进行解析后的结果**
无论前端发送的那种格式的数据，我们都可以以统一的方式读取数据
#### 常用属性
1）.data
request.data返回解析之后结果，与Django request.POST和request.FILES属性类似
特性：
- 包含了解析后的文件与非文件数据
- 包含对POST PUT PATCh请求方式解析后的数据
- 利用了rest的parser解析器，支持表单格式和JSON格式
2）.query_params
request.query_params与Django 标准的request.GET相同只是更换了名称而已
#### Response
rest_framework.response.Response
提供了一个响应的类Response,使用该类构造影响对象时，响应的具体数据内容会被转换为（render渲染）成符合前端需要的类型。

```python
rest提供一个渲染器，用来根据请求头Accept自动转换响应数据到对应格式。如果前端请求中未进行Accept声明，则会采用默认方式处理响应数据，我们可以通过配置来修改默认响应格式。
REST_FRAMEWORK={
    'DEFAULT_RENDERER_CLASSES':{
        # JSON渲染器
        'rest_framework.renderers.JSONRenderer'，
        # 浏览API渲染器
        'rest_framework.renderers.BrowsableAPIRenderer'
    }
}
```
3. 构造方法
Response(data,status,template_name,headers,content_type)
data(必填):给前端传序列化处理后的数据serializer.data
status(非必填):状态码默认200
template_name(非必填):模板名称，如果使用HTMLRenderer时使用
headers(非必填):响应头
content_type(非必填):响应数据Content

# APIView与View
1. 不同之处
- 传入视图中方法中的REST framework的Request对象
而不是Django的HttpRequest对象
- 视图方法可以返回Rest Framework 的Response对象，视图会为响应数据设置符合前端要求的格式
- 任何APIException异常都会被捕获到，并处理成合适的响应信息。
- 在进行dispatch()分发前会对请求进行身份认证，权限检查，流量控制
2. 支持定义的属性
- authentication_classes 列表或元组，身份认证类
- permission_classes 列表或元组，权限检查类
- throttle_classes 列表或元组，流量控制类
- 
# GenericAPIView
rest_framework.generics.GenericAPIView  
继承自APIView 主要增加了操作序列化器和数据库查询的方法，作用是为了下面Mixin扩展类的执行提供方法支持。通常在使用时可以搭配一个或者多个Mixin扩展类。  


## 提供了关于序列化器使用的属性和方法
### 属性：  
1. serialiszer_class 指明视图使用的序列化器  

### 方法：
1. get_serializer_class(self)
返回序列化器类，默认返回serializer_class,可以重写，例如
```python
def serializer_class(self):
    if self.request.user.is_staff:
        reutrn FullAccountSerializer
    return BasicAccountSerializer
```
2. get_serializer(self,args,*kwargs)
返回序列化器对象，主要用来提供给Mixin扩展类使用，如果我们在视图中想要获取序列化器对也可以直接调用此方法。  
==注意：此方法在提供序列化器对象时，会向序列化器对象的context属性补充三个数据：request,format,view,这三个数据对象可以在定义序列化器时使用==

## 提供了关于数据库查询的属性和方法
### 属性：
1. queryset指明使用的数据查询集
### 方法：
1. get_queryset(self)返回视图使用的查询集，主要用来mixin扩展使用，时列表视图与详情视图获取数据的基础，默认返回queryset属性可以重写，例如。
```python
def get_queryset(self):
    user = self.request.user
    return user.accounts.all()
```
2. get_object(self)
返回详情视图所需的模型类数据对象，主要用来提供给Mixin扩展类使用。
在视图中可以调用该方法获取详情信息的模型类对象
若详情访问的模型类对象不存在,会返回404.
该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。
举例子：
```python
class BookDetailView(GenericAPIView):
    queryset = BookInfo.objects.all()
    serializer_class =  BookInfoSerializer
    
    def get(self,request,pk):
        book = self.get_object()
        serializer = self.get_serializer(book)
        return Response(serializer.data)
```
## 其他可以设置的属性
1. pagination_class 指明分页控制类
2. filter_backends 指明过滤控制后端
==其中路由需要起别名，然后必须使用pk，因为内部是固定的


# 总结
## 创建接口流程
1. 安装
```shell
pip install djangorestframewrok
```
2. 创建文件serializer
    - 使用Serializer
    ```python
    # 英雄Ser
    class HeroInfoSerializer(serializers.Serializer):
        '''
        英雄类
        '''
        GENDER = [
            (0, '男'),
            (1, '女'),
            (2, '未知')
        ]
        hname = serializers.CharField(label='英雄名')
        hgender = serializers.ChoiceField(choices=GENDER, label='性别')
        hage = serializers.IntegerField(label='年龄')
        hcomment = serializers.CharField(label='备注')
    
    ```

    - 使用ModelSerializer类
    ```python
    from rest_framework import serializers
    from .models import BookInfo, HeroInfo
    
    # 书信息 Model
    class BookInfoModelSerializer(serializers.ModelSerializer):
        """定义序列化器"""
        class Meta:
            model = BookInfo # 指定序列化从那个模型映射字段
            fields = "__all__" # 映射哪些字段
            # 不映射那些字段
            # exclude=['btitle']
            # 设置属性
            # extra_kwargs={
                'bpub_date':{'label':'出版日期','required':True}
            }
            # 设置为只读
            # read_only_fields=['bpub_date']
    ```
3. 写视图函数
##  View
### 1.简介  
Django 自带的视图类
### 2.作用  
继承视图可以调用接口，实现增删改查功能
### 3.使用方法  
1. 序列化函数
无
2. 操作
```python
查询所有，新增图书：
class InitBookListView(View):
    '''
    列表视图
    '''
    def get(self,request):
        '''
        $查询所有图书$
        '''
        # 1. 查询所有图书模型
        books = BookInfo.objects.all()
        # 2. 遍历查询集，取出每一个对象，把模型转为字典。
        book_list = list()
        for book in books:
            book_dict = {
                'btitle': book.btitle,
                'bpub_date': book.bpub_date,
            }
            book_list.append(book_dict)
        # 3. 响应
        return JsonResponse(book_list, safe=False)

    def post(self,request):
        '''
        新增图书
        '''
        # 1. 获取前端传入的请求题，request.body
        json_str_bytes = request.body
        # 2. 把bytes类型的json字符串转换成，json_str
        json_str = json_str_bytes.decode()
        # 3. 利用json.loads将json字符串转为dict
        book_dict = json.loads(json_str)
        # 4. 创建一个新的数据库模型对象
        book_obj = BookInfo(
            btitle=book_dict['btitle'],
            bpub_date=book_dict['bpub_date']
        )
        book_obj.save()
        # 5. 插入数据
        # 6. 保存
        # 7. 返回数据状态码201
        json_dict = {
            'id': book_obj.id,
            'btitle': book_obj.btitle,
            'bpub_date': book_obj.bpub_date,
        }
        return JsonResponse(json_dict, status=201)
        
        
        
        
        
# 原始详情信息方法
class InitBookDetailView(View):
    '''
    列表视图
    '''

    def get(self, request, id):
        '''
        $查询指定某个图书接口$
        '''
        # 1. 获取指定的模型对象
        books = BookInfo.objects.filter(id=id).first()
        # 2. 模型对象转字典
        book_dict = dict()
        book_dict['name'] = books.btitle
        book_dict['bpub_date'] = books.bpub_date
        # 3. 响应
        return JsonResponse(book_dict, safe=False)

    def put(self, request, id):
        '''
        $修改指定图书接口$
        '''
        # 1. 查询是否有该对象
        try:
            book_obj = BookInfo.objects.get(id=id)
        except BookInfo.DoesNotExist as e:
            return HttpResponse({
                'msg':'修改的数据不存在'
            }, status=404)
        # 2. 获取当前传入的数据
        json_str_bytes = request.body
        json_str = json_str_bytes.decode()
        # 3. 把数据转换为字典
        book_dict = json.loads(json_str)
        # 4. 重新为模型指定的属性赋值
        book_obj.btitle = book_dict.get('btitle')
        book_obj.bpub_date = book_dict.get('bpub_date')
        book_obj.save()
        json_dict = {
            'id':book_obj.id,
            'btitle':book_obj.btitle,
            'bpub_date':book_obj.bpub_date
        }
        # 5. 响应
        return JsonResponse(json_dict)

    def delete(self, request, pk):
        '''
        $删除指定图书接口$
        '''
        # 1 获取删除的墨西哥对象
        # 2. 删除模型对象
        # 3. 响应：不需要有响应体，但是要有指定的状态码204
        data = {"status": 0}
        try:
            book = BookInfo.objects.get(id=pk)
            result = book.delete()
            data['status'] = 1
            data['msg'] = result
            return HttpResponse(str(result), status=204)
        except BookInfo.DoesNotExist as e:
            data['msg'] = str(e)
            return HttpResponse(str(data),status=404)


```

### 4.注意事项  
无

# APIView
### 1. 简介
rest_framework.views.APIView
是REST framework提供的所有视图的基类，继承自Django的View父类
与View的不同之处
- 传入到视图方法中的REST framework 的Request对象，而不是Django的HttpRequest对象
- 视图方法可以返回Rest framework的Response对象，视图会为响应数据设置符合前端要求的格式
- 任何APIException异常都会被捕获到，并且处理成合适的响应信息
- 在进行dispatch()分发前，会对请求进行身份认证，权限检查，流量控制

### 2. 作用
可以比View更加方便返回数据

### 3. 使用方法
返回使用
from rest_framework.response import Response
from rest_framework.views import APIView
```python

查询和修改
class BookInfoApiView(APIView):
    # 根据ID进行查询
    def get(self,request,pk):
        book = BookInfo.objects.get(id=pk)
        ser = BookInfoSerializer(instance = book)
        return Response(ser.data)  
    
    # 修改数据的全部，patch是修改一部分
    class put(self,request,pk):
        book = BookInfo.objects.get(id=pk)
        data = request.data
        ser_data = BookInfoSerializer(instance=book, data=data)
        if ser_data.is_valid():
            ser_data.save()
            return HttpResponse('ok')
        return HttpResponse(str(ser_data.errors))
        
    class delete(self,request,pk):
        book = BookInfo.objects.get(id=pk)
        book.delete() 
        return Response()
        
class BookInfoDetailAPIView(APIView):

    # 查询所有
    class get(self,request):
        book = BookInfo.objects.all()
        serializer = BookINfoSerializer(instance=book,many=True)
        return Response(serializer.data)
    # 新增用户
    def post(self,request,pk):
        data = request.data
        ser = BookInfoSerializer(data=data)
        ser.is_valid(raise_exception=True)
        ser.save()
        print(ser.data)
        return Response(ser.data,status=status.HTTP_200_OK)
```


### 4. 注意事项
一般定义两个视图，一个新增视图一个详情视图







